use proc_macro::TokenStream;
use proc_macro2::{Ident, Span};
use quote::quote;
use syn::{parse::Parse, parse_macro_input, Attribute, ItemTrait, Token};

use crate::utils::fp::{CloneFP, OptionFP, ResultFP};

pub(crate) fn get_reflect_trait(name: &str) -> Ident {
    let reflected = format!("GetTrait{name}");
    Ident::new(&reflected, Span::call_site())
}

pub(crate) struct TraitInfo {
    item_trait: ItemTrait,
}

impl Parse for TraitInfo {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let attrs = input.call(Attribute::parse_outer)?;
        let lookahead = input.lookahead1();
        if lookahead.peek(Token![pub]) || lookahead.peek(Token![trait]) {
            let mut item_trait: ItemTrait = input.parse()?;
            item_trait.attrs = attrs;
            Ok(TraitInfo { item_trait })
        } else {
            Err(lookahead.error())
        }
    }
}

/// A trait attribute macro that allows a reflected type to be downcast to a trait object.
///
/// This generates a struct that takes the form `ReflectMyTrait`. An instance of this struct can then be
/// used to perform the conversion.
pub(crate) fn reflect_trait(_args: &TokenStream, input: TokenStream) -> TokenStream {
    let trait_info = parse_macro_input!(input as TraitInfo);
    let item_trait = &trait_info.item_trait;
    let trait_ident = &item_trait.ident;
    let trait_vis = &item_trait.vis;
    let reflect_trait_ident = get_reflect_trait(&item_trait.ident.to_string());
    

    let struct_doc = format!(
        " A type generated by the #[reflect_trait] macro for the `{trait_ident}` trait.\n\n This allows casting from `dyn Reflect` to `dyn {trait_ident}`.",
    );
    let get_doc = format!(
        " Downcast a `&dyn Reflect` type to `&dyn {trait_ident}`.\n\n If the type cannot be downcast, `None` is returned.",
    );
    let get_mut_doc = format!(
        " Downcast a `&mut dyn Reflect` type to `&mut dyn {trait_ident}`.\n\n If the type cannot be downcast, `None` is returned.",
    );
    let get_box_doc = format!(
        " Downcast a `Box<dyn Reflect>` type to `Box<dyn {trait_ident}>`.\n\n If the type cannot be downcast, this will return `Err(Box<dyn Reflect>)`.",
    );

    let vct_reflect_path = crate::path::vct_reflect();
    let reflect_path = crate::path::reflect_(&vct_reflect_path);
    let alloc_utils_path = crate::path::alloc_utils_(&vct_reflect_path);
    let from_type_path = crate::path::from_type_(&vct_reflect_path);

    TokenStream::from(quote! {
        #item_trait

        #[doc = #struct_doc]
        #[derive(#CloneFP)]
        #trait_vis struct #reflect_trait_ident {
            get_func: fn(&dyn #reflect_path) -> #OptionFP<&dyn #trait_ident>,
            get_mut_func: fn(&mut dyn #reflect_path) -> #OptionFP<&mut dyn #trait_ident>,
            get_boxed_func: fn(#alloc_utils_path::Box<dyn #reflect_path>) -> #ResultFP<#alloc_utils_path::Box<dyn #trait_ident>, #alloc_utils_path::Box<dyn #reflect_path>>,
        }

        impl #reflect_trait_ident {
            #[doc = #get_doc]
            #[inline(always)]
            pub fn get<'a>(&self, reflect_value: &'a dyn #reflect_path) -> #OptionFP<&'a dyn #trait_ident> {
                (self.get_func)(reflect_value)
            }

            #[doc = #get_mut_doc]
            #[inline(always)]
            pub fn get_mut<'a>(&self, reflect_value: &'a mut dyn #reflect_path) -> #OptionFP<&'a mut dyn #trait_ident> {
                (self.get_mut_func)(reflect_value)
            }

            #[doc = #get_box_doc]
            #[inline(always)]
            pub fn get_boxed(&self, reflect_value: #alloc_utils_path::Box<dyn #reflect_path>) -> #ResultFP<#alloc_utils_path::Box<dyn #trait_ident>, #alloc_utils_path::Box<dyn #reflect_path>> {
                (self.get_boxed_func)(reflect_value)
            }
        }

        impl<T: #trait_ident + #reflect_path> #from_type_path<T> for #reflect_trait_ident {
            fn from_type() -> Self {
                Self {
                    get_func: |reflect_value| {
                        <dyn #reflect_path>::downcast_ref::<T>(reflect_value).map(|value| value as &dyn #trait_ident)
                    },
                    get_mut_func: |reflect_value| {
                        <dyn #reflect_path>::downcast_mut::<T>(reflect_value).map(|value| value as &mut dyn #trait_ident)
                    },
                    get_boxed_func: |reflect_value| {
                        <dyn #reflect_path>::downcast::<T>(reflect_value).map(|value| value as #alloc_utils_path::Box<dyn #trait_ident>)
                    }
                }
            }
        }
    })
}
